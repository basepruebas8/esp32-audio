<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Escuchar — WebSocket + AudioContext</title>
  <style>
    :root { color-scheme: dark; }
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:24px; background:#0b1020; color:#e9eef5}
    .card{max-width:820px;margin:auto;background:#111936ee;border:1px solid #233152;border-radius:16px;padding:18px;box-shadow:0 10px 30px #0006}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    input,button,select{border-radius:10px;border:1px solid #26314a;background:#0e162b;color:#e9eef5;padding:10px 12px}
    input[type="range"]{width:220px}
    button{background:linear-gradient(180deg,#2a8bd7,#1c66a1);border:none;font-weight:700;cursor:pointer}
    button:disabled{opacity:.55;cursor:not-allowed}
    .meter{height:12px;background:#0e162b;border:1px solid #26314a;border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0%;background:linear-gradient(90deg,#33e1a8,#7cf4ff)}
    small{color:#9fb0c9}
    h1{margin:0 0 8px 0;font-size:22px}
    .sp{height:10px}
  </style>
</head>
<body>
  <div class="card">
    <h1>Escuchar — Cliente WebSocket + AudioContext</h1>

    <div class="row">
      <label for="ws">Servidor WSS</label>
      <input id="ws" style="flex:1" value="wss://audio-32.deno.dev/?room=demo&role=listener" />
      <button id="play">▶︎ Escuchar</button>
      <button id="stop" disabled>■ Detener</button>
    </div>

    <div class="sp"></div>

    <div class="row">
      <label for="buf">Buffer (jitter): <span id="bufv">100</span> ms</label>
      <input id="buf" type="range" min="40" max="240" step="10" value="100" />
      <label><input type="checkbox" id="hpf" checked> High-pass 100 Hz</label>
      <label><input type="checkbox" id="lpf" checked> Low-pass 4.5 kHz</label>
      <label><input type="checkbox" id="comp" checked> Compresor (voz)</label>
    </div>

    <div class="sp"></div>

    <div class="meter"><div id="vu" class="bar"></div></div>
    <small>Nivel (RMS aprox.)</small>

    <p class="sp"></p>
    <small>Tip: también puedes abrir con <code>?ws=wss://…&room=demo</code> en la URL.</small>
  </div>

  <script>
  // Lee parámetros ?ws y ?room para autocompletar
  (function () {
    const p = new URLSearchParams(location.search);
    const ws = p.get('ws'); const room = p.get('room');
    if (ws) {
      const val = ws + (ws.includes('room=') || !room ? '' : '&room=' + encodeURIComponent(room));
      document.getElementById('ws').value = val;
    } else if (room) {
      const i = document.getElementById('ws');
      if (!i.value.includes('room=')) i.value += (i.value.includes('?') ? '&' : '?') + 'room=' + encodeURIComponent(room);
    }
  })();

  const vu  = document.getElementById('vu');
  const buf = document.getElementById('buf');
  const bufv= document.getElementById('bufv');
  const hpfC= document.getElementById('hpf');
  const lpfC= document.getElementById('lpf');
  const cmpC= document.getElementById('comp');
  buf.oninput = ()=> bufv.textContent = buf.value;

  let ctx, worklet, socket;
  let hpf, lpf, comp;

  // Código del AudioWorklet: buffer de jitter + re-muestreo lineal + VU
  const workletCode = `
    class NetPlayer extends AudioWorkletProcessor {
      constructor(){ super();
        this.inRate = 16000;           // el ESP32 envía PCM16 @16 kHz
        this.targetMs = 100;           // jitter objetivo
        this.queue = [];               // cola de Float32
        this.queued = 0;               // muestras en cola (a 16 kHz)
        this.started = false;
        this.port.onmessage = (e)=>{
          const d = e.data;
          if (d && d.type === 'cfg'){ this.targetMs = d.ms|0; return; }
          // d es un ArrayBuffer con PCM16
          const s16 = new Int16Array(d);
          const f32 = new Float32Array(s16.length);
          for (let i=0;i<s16.length;i++) f32[i] = s16[i]/32768;
          this.queue.push(f32); this.queued += f32.length;
        };
      }
      _resample(src,inR,outR){
        if (inR===outR) return src;
        const ratio = outR/inR;
        const out = new Float32Array(Math.round(src.length*ratio));
        for (let i=0;i<out.length;i++){
          const x = i/ratio, xi = Math.floor(x), t = x - xi;
          const a = src[xi] ?? 0, b = src[xi+1] ?? a;
          out[i] = a + (b-a)*t;
        }
        return out;
      }
      process(_, outputs){
        const out = outputs[0][0]; out.fill(0);
        const want = Math.round(this.inRate*(this.targetMs/1000));
        if (!this.started){ if (this.queued < want) return true; this.started = true; }
        let w=0, acc=0, n=0;
        while (w<out.length && this.queue.length){
          let chunk = this.queue[0];
          // re-muestrea al sampleRate del contexto (global)
          chunk = this._resample(chunk, this.inRate, sampleRate);
          const need = Math.min(out.length-w, chunk.length);
          out.set(chunk.subarray(0,need), w);
          for (let i=0;i<need;i++){ const v = chunk[i]; acc += v*v; }
          n += need; w += need;
          if (need < chunk.length){
            this.queue[0] = chunk.subarray(need);
            this.queued -= Math.round(need*(this.inRate/sampleRate));
          } else {
            this.queue.shift();
            this.queued -= Math.round(chunk.length*(this.inRate/sampleRate));
          }
        }
        if (n){
          const vu = Math.sqrt(acc/n);
          this.port.postMessage({type:'vu', v:vu});
        }
        return true;
      }
    }
    registerProcessor('net-player', NetPlayer);
  `;
  const workletURL = URL.createObjectURL(new Blob([workletCode], {type:'application/javascript'}));

  async function startAudio(){
    if (!ctx){
      const AC = window.AudioContext || window.webkitAudioContext;
      ctx = new AC();
      await ctx.audioWorklet.addModule(workletURL);
      worklet = new AudioWorkletNode(ctx, 'net-player');
      // Filtros (opcionales)
      hpf = ctx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=100;
      lpf = ctx.createBiquadFilter(); lpf.type='lowpass';  lpf.frequency.value=4500;
      comp = ctx.createDynamicsCompressor();
      // Cadena por defecto
      updateChain();
      worklet.port.onmessage = (e)=>{
        if (e.data?.type==='vu'){
          const db = 20*Math.log10(e.data.v+1e-6); // -inf..0
          const pct = Math.min(100, Math.max(0, (db+60)/60*100));
          vu.style.width = pct+'%';
        }
      };
    }
    if (ctx.state === 'suspended') await ctx.resume();
  }

  function updateChain(){
    // Desconecta todo primero
    try{ worklet.disconnect(); }catch{}
    try{ hpf.disconnect(); }catch{}
    try{ lpf.disconnect(); }catch{}
    try{ comp.disconnect(); }catch{}
    // Reconecta según checkboxes
    let node = worklet;
    if (hpfC.checked){ node.connect(hpf); node = hpf; }
    if (lpfC.checked){ node.connect(lpf); node = lpf; }
    if (cmpC.checked){ node.connect(comp); node = comp; }
    node.connect(ctx.destination);
  }
  [hpfC,lpfC,cmpC].forEach(el=>el.addEventListener('change', ()=>{ if (ctx) updateChain(); }));

  function connectWS(){
    const url = document.getElementById('ws').value.trim();
    try{ if (socket) socket.close(); }catch(_){}
    socket = new WebSocket(url);
    socket.binaryType = 'arraybuffer';
    socket.onopen    = ()=>console.log('WS abierto');
    socket.onclose   = ()=>console.log('WS cerrado');
    socket.onerror   = (e)=>console.log('WS error', e);
    socket.onmessage = (ev)=> {
      // Enviamos el ArrayBuffer al worklet (transferencia cero-copia)
      worklet.port.postMessage(ev.data, [ev.data]);
    };
  }

  document.getElementById('play').onclick = async ()=>{
    document.getElementById('play').disabled = true;
    try{
      await startAudio();
      worklet.port.postMessage({type:'cfg', ms: parseInt(buf.value,10)});
      connectWS();
      document.getElementById('stop').disabled = false;
    }catch(e){
      alert('No se pudo iniciar audio: '+e);
      document.getElementById('play').disabled = false;
    }
  };

  document.getElementById('stop').onclick = ()=>{
    try{ if (socket) socket.close(); }catch(_){}
    try{ if (ctx && ctx.state!=='closed') ctx.suspend(); }catch(_){}
    document.getElementById('stop').disabled = true;
    document.getElementById('play').disabled = false;
  };

  buf.addEventListener('change', ()=>{ if (worklet) worklet.port.postMessage({type:'cfg', ms: parseInt(buf.value,10)}); });
  </script>
</body>
</html>
